jvm Java virtual machine  gc  垃圾收集器
1内存分区 运行时数据区域划分,一共分为五大部分,分别是：
程序计数器,Java虚拟机栈,本地方法栈,Java堆（堆内内存）,元空间（位于堆外内存 方法区被废弃）
！线程私有：程序计数器,Java虚拟机栈,本地方法栈。
！可能内存溢出的区域：堆（虚拟机分配的大小）、元空间（理论上系统内存大小）、Java虚拟机栈,本地方法栈
！会自动垃圾回收的区域：堆内内存。Java虚拟机规范的规定可以不实现方法区垃圾回收，
因为方法区是对废弃常量的回收和对无用类的回收，效率低。


方法区和永久代的关系很像Java中接口和类的关系，类实现了接口，
而永久代就是HotSpot虚拟机对虚拟机规范中方法区的”一种实现方式“。

！堆外内存（直接内存 本地内存）含义、好处？
定义：内存对象分配在Java虚拟机的堆以外的内存，这些内存直接受操作系统管理（而不是虚拟机）。
创建方式：用未公开的Unsafe和NIO包下ByteBuffer来创建堆外内存，Unsafe提供了另一个接口freeMemory可以对申请的堆外内存进行释放。
优点：
一、堆外内存是直接受操作系统管理，”减少垃圾回收对应用程序造成的影响“；
二、提升复制速度(io效率)
堆内内存由JVM管理，属于“用户态”；而堆外内存由OS管理，属于“内核态”。
如果从堆内向磁盘写数据时，数据会被先复制到堆外内存，即内核缓冲区，然后再由OS写入磁盘，使用堆外内存避免了这个操作。
缺点：需要手动释放



！！！1.7、1.8运行时常量池、方法区、元空间变化？（HotSpot虚拟机）
在JDK1.6及之前，运行时常量池是方法区的一个部分，同时方法区里面存储了类的元数据信息、静态变量、
即时编译器编译后的代码（比如spring 使用IOC或者AOP创建bean时，或者使用cglib，反射的形式动态生成class信息等）等。

在JDK1.7及以后，JVM已经将运行时常量池从方法区中移了出来，”在JVM堆开辟了一块区域存放常量池“。
改动原因：字符串存在永久代中，容易出现性能问题和内存溢出。
https://www.jianshu.com/p/0d1c003d2ff5
引起方法差异：String.intern()是一个Native方法：
return  a string that has the same contents as this string, but is
     *          guaranteed to be from a pool of unique strings.
当调用 intern 方法时，如果常量池中已经该字符串，则返回池中的字符串；否则将此字符串添加到常量池中，并返回字符串的引用。
即保证返回字符串都位于常量池。考虑常量池中一开始就已经存在 "java" 等字符串！
在JDK6中，常量池在永久代分配内存，永久代和Java堆的内存是物理隔离的；
在JDK7中，常量池已经在Java堆上分配内存，执行intern方法时，
先查询字符串常量池是否存在当前字符串，“！若字符串常量池中不存在则再从堆中查询”，然后存储并返回相关引用；
若都不存在则将当前字符串复制到字符串常量池中，并返回字符串常量池中的引用。



在1.8之后已经取消了永久代（方法区），改为元空间（matespace），类的元信息被存储在元空间中。
元空间使用堆不相连的本地内存区域。理论上系统可以使用的内存有多大，元空间就有多大，所以”不会出现永久代存在时的内存溢出问题“。
！！！改动的原因：
1。方法区不要求垃圾回收，但又位于与堆（会垃圾回收）相连的内存区域，不合理，
比如方法区的元数据随着垃圾回收会发生移动，会消耗虚拟机性能。
2。永久代的大小指定比较困难，太小容易出现永久代溢出，太大则容易导致老年代溢出。
2。方法区加载类，读取类文件涉及到磁盘IO，采用堆外内存可以提高效率。


2如何判别回收对象 引用计数法（循环引用） 可达性分析（root引用链 类的（静态）常量变量 虚拟机、本地方法栈变量）

3垃圾回收算法 标记复制  |标记清除（有内存碎片） 标记整理

4minor gc   major gc  full gc （STW stop the world 进程停止）
Minor GC：新生代GC，指发生在新生代的垃圾收集动作，所有的Minor GC都会触发全世界的暂停（stop-the-world），停止应用程序的线程，
不过这个过程非常短暂。
！！！Minor GC触发条件：”当JVM 无法为一个新的对象分配空间时会触发 Minor GC，比如当 Eden 区满了！“，
这时会把Eden区存活的对象复制到Survivor区，当对象在Survivor区熬过一定次数的Minor GC之后，
就会晋升到老年代（当然并不是所有的对象都是这样晋升的到老年代的），
质疑常规的认知，所有的 Minor GC 都会触发“全世界的暂停（stop-the-world）”，停止所有应用程序的线程。
对于大部分应用程序，停顿导致的延迟都是可以忽略不计的。其中的真相就 是，大部分 Eden 区中的对象都能被认为是垃圾，
永远也不会被复制到 Survivor 区或者老年代空间。如果正好相反，Eden 区大部分新生对象不符合 GC 条件，
Minor GC 执行时暂停的时间将会长很多。

Major GC：老年代GC，指发生在老年代的GC。
出现了 Major GC，经常会伴随至少一次的 Minor GC。MajorGC 的速度一般会比 Minor GC 慢 10倍以上。
关注当前的 GC 是否停止了所有应用程序的线程，还是能够并发的处理而不用停掉应用程序的线程。
！！！Mayjor GC触发条件：当Minor GC回收后空间仍然不够， 或者 创建大的对象但是老年代空间不够。
"当老年代满了，就会报OutofMemory异常。"

Full GC：清理整个堆空间—包括年轻代和老年代
许多major GC是由minor GC触发的，所以很难将这两种垃圾回收区分开，因此major GC和full GC通常是等价的。


在执行机制上JVM提供了串行GC（SerialGC）、并行回收GC（ParallelScavenge）和并行GC（ParNew）
1）串行GC
在整个扫描和复制过程采用 单线程！的方式来进行，
适用于 单CPU、新生代空间较小及对 暂停时间要求不是非常高的应用上！！！，是client级别默认的GC方式，
可以通过-XX:+UseSerialGC来强制指定
2）并行回收GC
在整个扫描和复制过程采用多线程！的方式来进行，适用于 多CPU、对暂停时间要求较短的应用上！！，是server级别默认采用的GC方式，
可用-XX:+UseParallelGC来强制指定，用-XX:ParallelGCThreads=4来指定线程数

新生代 ( Young ) = 1/3 的堆空间大小。老年代 ( Old ) = 2/3 的堆空间大小。
其中，新生代 ( Young ) 被细分为 Eden 和 两个 Survivor 区域，这两个 Survivor 区域分别被命名为 from 和 to，以示区分
默认的，Edem : from : to = 8 :1 : 1 

当对象的年龄达到某个值时 ( 默认是 15 岁，可以通过参数 -XX:MaxTenuringThreshold 来设定 )，
或者对于一些较大的对象 ( 即需要分配一块较大的连续内存空间 ) 则是进入到老年代。


垃圾回收器：串行serial收集器| 并行CMS、G1
Serial收集器：是一个单线程的年轻代收集器，当它运行进行垃圾回收时，
其它工作线程必须被停止，直到它收集完成。serial依然是JVM client模式下的默认收集器，对于client模式是一个很好的选择。
 
Server模式下：以获取最短回收停顿时间为目标，重视服务的响应速度，以给用户带来较好的体验，垃圾回收线程和用户线程并行
CMS:（并发减少停顿时间 四个步骤）
Concurrent Mark Sweep 
CMS是基于 标记-清除 算法的老年代垃圾收集器，它的运作分为4个步骤，
1初始标记：仅仅只是标记一下GC Roots能 直接关联 到的对象，速度很快，
2并发标记阶段：进行GC Roots Tracing的过程（从GCRoot往下搜索）
3重新标记阶段：为了修正并发标记期间因用户程序继续运作而导致标记产生的变动，
（因为tracing过程和用户线程并发，可能出现标记变化（小部分），需要重新标记）
这个阶段的停顿时间一般会比初始标记阶段稍长一些，但远比并发标记的时间短。
4并发回收
只有初始标记和重新标记需要暂停用户线程STW（stop the world）！！！
由于整个过程中耗时最长的并发标记和并发清除过程收集器线程都可以与用户线程一起工作，
所以，总体上来说，CMS收集器的内存回收过程是与用户线程一起并发执行的。

G1 Garbage First：它是一个整堆收集器
（并发减少停顿时间 并行利用多核环境! 可预测停顿时间Nms! 优先队列回收价值大的Region!）
运作同样分为4个步骤，但与CMS的“标记-清除”算法不同，G1基于“标记-整理”算法收集老年代，基于“标记-复制”算法收集年轻代
1G1能充分利用 多CPU、多核 环境下的硬件优势，使用多个CPU来缩短停顿时间，

2可预测的停顿：降低停顿时间是G1和CMS共同关注点， 但G1除了追求低停顿外，还能建立可预测的停顿时间模型，
指定N ms标明垃圾收集期望停顿时间，表明垃圾回收最多不超过N ms。

3G1将整个java堆划分为多个大小想等的独立区域（Region），虽然还保留有新生代和老年代的概念，
但新生代和老年代不再是物理隔离了，它们都是一部分Region（不需要连续）的集合。
G1跟踪各个region里面的垃圾堆积的价值大小（选择回收所获得的空间大以及回收所需时间少的），
在后台维护一个优先列表，每次根据允许的手机时间，优先回收价值最大的Region。
这种使用Region划分内存空间以及有优先级的区域回收方式，保证了G1收集器在有限的时间内可以获取尽可能高的收集效率。



对象头就是用于保存对象的信息，包含：
1Mark Word包括哈希码（HashCode）、GC分代年龄、
锁状态标志（未锁定、偏向锁、轻量级锁、重量级锁、GC标记）、
线程持有的锁（lock_record字段指向线程栈的Monitor Record对象）、偏向线程ID等。

2class pointer用于存储对象的类型指针，确定对象是哪个类的实例。
3.array length如果对象是一个数组，用于存储数组的长度。

对象包括：对象头、实例数据、填充对齐。

Monitor对象在sychronized实现？
同步是使用monitorenter和monitorexit指令实现，monitorenter指令是在编译后插入到同步代码块的开始位置，
而monitorexit是插入到方法结束处和异常处
线程执行到 monitorenter 指令时，将会尝试获取对象所对应的 monitor 的所有权，即尝试获得对象的锁。
对象头里的mark word里的lock_record字段指向线程栈的Monitor Record对象（实现对象锁与线程的关联）
任何对象都有一个 monitor 与之关联，当且一个monitor 被持有后，它将处于锁定状态。


强软弱虚：Stong 、Soft、Weak、Phantom Reference
强引用：
只要引用存在，垃圾回收器永远不会回收
Object obj = new Object();
//可直接通过obj取得对应的对象 如obj.equels(new Object());
而这样 obj对象对后面new Object的一个强引用，只有当obj这个引用被释放之后，对象才会被释放掉，这也是我们经常所用到的编码形式。

软引用：
非必须引用，“内存溢出之前进行回收”，可以通过以下代码实现
Object obj = new Object();
SoftReference<Object> sf = new SoftReference<Object>(obj);
obj = null;
sf.get();//有时候会返回null
这时候sf是对obj的一个软引用，通过sf.get()方法可以取到这个对象，当然，当这个对象被标记为需要回收的对象时，则返回null；
“软引用主要用户实现类似缓存的功能”，在内存足够的情况下直接通过软引用取值，无需从繁忙的真实来源查询数据，提升速度；
当内存不足时，自动删除这部分缓存数据，从真正的来源查询这些数据。

弱引用：
第二次垃圾回收时回收，可以通过如下代码实现
Object obj = new Object();
WeakReference<Object> wf = new WeakReference<Object>(obj);
obj = null;
wf.get();//有时候会返回null
wf.isEnQueued();//返回是否被垃圾回收器标记为即将回收的垃圾
弱引用是在第二次垃圾回收时回收，短时间内通过弱引用取对应的数据，可以取到，当执行过第二次垃圾回收时，将返回null。
“弱引用主要用于监控对象是否已经被垃圾回收器标记为即将回收的垃圾”，可以通过弱引用的isEnQueued方法返回对象是否被垃圾回收器标记。

虚引用：
垃圾回收时回收，无法通过引用取到对象值，可以通过如下代码实现
Object obj = new Object();
PhantomReference<Object> pf = new PhantomReference<Object>(obj);
obj=null;
pf.get();//永远返回null
pf.isEnQueued();//返回是否从内存中已经删除
虚引用是每次垃圾回收的时候都会被回收，通过虚引用的get方法永远获取到的数据为null，因此也被成为幽灵引用。
“虚引用主要用于检测对象是否已经从内存中删除”。

实际哪里有用到其他三种引用？
ThreadLocal里，Thread持有的ThreadLocalMap的key，是threadlocal的一个弱引用，
可以访问到threadlocal又避免threadlocal无法回收导致的内存泄漏。

https://www.jianshu.com/p/a9b2c2ac84a7
内存泄漏是什么？
内存泄漏是指无用对象（不再使用的对象）持续占有内存或得不到及时释放，从而造成内存空间的浪费称为内存泄漏，
严重时堆积导致Out of memory。
内存泄漏的根本原因是什么呢？？？
“长生命周期的对象持有短生命周期对象的引用”，尽管短生命周期对象已经不再需要，但是因为长生命周期持有它的引用而导致不能被回收
常见情况？
1当“集合”里面的对象属性被修改后，导致哈希值改变，contains()或者get()找不到，也无法再调用remove()进行删除。
例如：public static void main(String[] args){    Set set = new HashSet();    Person p1 = new Person("唐僧","pwd1",25);    Person p2 = new Person("孙悟空","pwd2",26);    Person p3 = new Person("猪八戒","pwd3",27);    set.add(p1);    set.add(p2);    set.add(p3);    System.out.println("总共有:"+set.size()+" 个元素!"); //结果：总共有:3 个元素!    p3.setAge(2); //修改p3的年龄,此时p3元素对应的hashcode值发生改变    set.remove(p3); //此时remove不掉，造成内存泄漏    set.add(p3); //重新添加，居然添加成功    System.out.println("总共有:"+set.size()+" 个元素!"); //结果：总共有:4 个元素!    for (Person person : set)    {        System.out.println(person);    }}
2各种“连接”（finally{close()}）
比如数据库连接（dataSourse.getConnection()），网络连接(socket)和io连接，除非其显式的调用了其close（）方法将其连接关闭，
否则是不会自动被GC 回收的。
3“内部类持有外部类”，如果一个外部类的实例对象的方法返回了一个内部类的实例对象，这个内部类对象被长期引用了，
即使那个外部类实例对象不再被使用，但由于内部类持有外部类的实例对象，这个外部类对象将不会被垃圾回收，这也会造成内存泄露。



内存溢出Out of memory可能发生在哪、什么情况下（除了程序计数器）？？？
！可能内存溢出Out of memory的区域：
1堆（虚拟机分配的大小）：
所有的对象和数组都在堆上进行分配。这部分空间可通过 GC 进行回收。当申请不到空间时会抛出 OutOfMemoryError。

2Java虚拟机栈,本地方法栈：
栈里面存着的是一种叫“栈帧”的东西，每个方法会创建一个栈帧，
栈帧中存放了局部变量表（基本数据类型和对象引用）、操作数栈、方法出口等信息。
当栈调用深度大于JVM所允许的范围，会抛出StackOverflowError的错误。

3元空间（理论上系统内存大小）：
1.8之前GC不会在主程序运行期对永久区域进行清理，导致了永久代的区域会随着加载的Class的增多而胀满，最终抛出OOM异常。
1.8元空间理论上在系统内存不够时溢出。

jvm指定参数vm options
-Xms 堆最小容量(heap min size)
-Xmx 堆最大容量(heap max size)
-Xss 栈容量(stack size)
-XX:PermSize=size 永生代最小容量
-XX:MaxPermSize=size 永生代最大容量


！！！如何排查？通过调优命令，进而定位到具体代码。
JVM调优，jvm参数、调优命令：jstat、jmap、jstack、jps等等
jps（Java Virtual Machine Process Status Tool）
jps主要用来输出JVM进程ID、启动类名、参数等
也可以
ps -ef|grep javaname （获得java进程ID ）

Jmap
打印出某个java进程（指定pid）的所有‘对象’的情况（如：产生那些对象，及其数量）。

jstack主要用来查看某个Java进程内的所有“线程堆栈！”信息，再grep线程ID获取指定线程堆栈（配合top查看进程的指定线程ID），
最终通过线程堆栈可以定位到具体的类的方法。
不仅可以输出Java堆栈信息，还会输出C/C++堆栈信息（比如Native方法）

jstat（JVM统计监测工具）
vmid是虚拟机ID，在Linux/Unix系统上一般就是进程ID。
jstat -gccause 额外输出上次GC原因   
jstat -class 类装载、总空间及消耗空间 


常见问题
1、频繁GC或者内存溢出（定位堆和监控信息：jps/ps--jmap/jstat）
   使用jps查看进程ID,jstat监控堆gc情况，上次gc原因，jmap生成堆转存文件dump，
   如果发生内存泄漏：找到泄漏对象的GC Root，定位代码设法解除泄漏对象与GCRoot的连接
   如果不存在泄漏:看下是否能增大jvm堆的最大容量
   
2、死锁问题/cpu耗费高问题（定位具体线程堆栈：jps/ps--top--jstack--代码）

！！！来一个实例找出“某个Java进程中最耗费CPU的Java线程并定位堆栈”信息，用到的命令有ps、top、printf、jstack、grep。
1第一步先找出Java进程ID，ps -ef|grep javaname|grep -v grep或者jps得到进程ID21711
2“第二步找出该进程内最耗费CPU的线程，使用top -Hp pid”
TIME列就是各个Java线程耗费的CPU时间，CPU时间最长的是线程ID为21742的线程，用
printf "%x\n" 21742
得到21742的十六进制值为54ee，下面会用到。
4“第三步定位类和方法”，通过jstack输出进程21711的堆栈信息，然后根据线程ID的十六进制值grep，如下：
root@ubuntu:/# jstack 21711 | grep 54ee
"PollIntervalRetrySchedulerThread" prio=10 tid=0x00007f950043e000 nid=0x54ee in Object.wait() [0x00007f94c6eda000]
可以看到CPU消耗在PollIntervalRetrySchedulerThread这个类的Object.wait()，最后定位到代码，进行分析。




finalize()是Object的protected方法，子类可以覆盖该方法以实现资源清理工作。
GC在回收对象之前调用该方法，由于GC有不确定性，因此finalize的调用具有不确定性。
Java语言规范并不保证finalize方法会被及时地执行、而且根本不会保证它们会被执行。
不建议用finalize方法完成“内存资源”的清理工作，但建议用于：① 清理本地对象(通过JNI创建的对象)；
② 作为确保某些非内存资源(如Socket、文件等)释放的
对象再生问题：finalize方法中，可将待回收对象赋值给GC Roots可达的对象引用，从而达到对象再生的目的
执行流程：当对象变成(GC Roots)不可达时，“第一次标记”，GC会判断该对象是否覆盖了finalize方法，若未覆盖，则直接将其回收。
否则，若对象未执行过finalize方法，真正被宣告死亡的时候，至少需要经过两次标记。
将其放入F-Queue队列，由一低优先级线程执行该队列中对象的finalize方法。
“第二次标记”，GC会再次判断该对象是否可达，若不可达，则进行回收，否则，对象“复活”。

sysyem.gc()其实是做一次full gc，会暂停整个进程
gc()函数的作用只是提醒虚拟机：“程序员希望进行一次垃圾回收。但是它不能保证垃圾回收一定会进行”，
而且具体什么时候进行是取决于具体的虚拟机的，不同的虚拟机有不同的对策。

我的建议是：保持代码健壮（记得将不用的变量置为null），避免内存泄漏的情况，让虚拟机去管理内存。
不要频繁使用gc函数。

