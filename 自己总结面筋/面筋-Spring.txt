Update: It's Mar 2016 now. Spring Boot offers an even better way to write applications without Java EE app servers. 
You can create an executable JAR and run it on a JVM.
I wonder if Oracle will continue to support the Java EE spec. Web services have taken over for EJBs. 
The EJB solution is dead. (Just my opinion.)
都是提供企业级服务。
EJB是官方标准，可以移植到支持该标准的架构服务器，但也有偏差。
Spring开源
springboot提供自动配置、提供多个starter项目，可以生成可执行的jar，快速搭建应用，支持Java配置中声明servlet和filter，
不再需要web.xml以及Springcloud等完整生态圈。
-----------------------------------------
Model：是为页面提供数据和数据校验的
Entity：是专用于EF的对数据库表的操作，把对某一个表的操作全写在一个类中
说白了就是为了让程序员在对数据库操作的时候不用写SQL语句，就是一个数据库表生成一个类 
这样做对数据库操作起来方便，编写代码较少提高效率。
Entity接近原始数据，Model接近业务对象～
POJO（Plain Ordinary Java Object）简单的Java对象，
（POJO其实是比javabean更纯净的简单类或接口。POJO严格地遵守简单对象的概念，而一些JavaBean中往往会封装一些简单逻辑。）
使用POJO名称是为了避免和EJB混淆起来, 而且简称比较直接. 其中有一些属性及其getter setter方法的类,没有业务逻辑，有
时可以作为VO(value -object)或dto(Data Transform Object)来使用.当然,如果你有一个简单的运算属性也是可以的,
但不允许有业务方法,也不能携带有connection之类的方法。
--------------------------------------------------------
spring模块对应不同的jar包，涵盖企业级所需可以自由选择，并且提供第三方集成接口
大致：测试、spring核心容器、AOP、instrumentation、数据访问集成（JDBC、transaction、ORM等）、Web与远程调用（websocket Webservlet等）
所有模块构建于核心容器之上
spring没有建立自己的ORM模块，而是对流行的ORM（mybatis、hibernate、jpa等）进行集成，ORM模块建立在对JDBC的支持上
DAO 接口：Data Access Object 数据访问对象，把数据库相关的操作都封装在这个类里面，其他地方看不到JDBC的代码
ORM：Object Relationship Database Mapping，对象和关系数据库的映射，简单地说，一个对象，对应数据库里的一条记录，
从而大大简化原来直接使用JDBC时，手工拼写SQL带来的不便。减少JDBC的样板式代码，并对数据库的连接查询等作优化。


如果使用侵入式的框架，一般需要继承或者实现框架的某一个类或接口，导致和框架绑死，把框架换掉以后就会运行不起来，在代码层面报错。
spring的低耦合的耦合是什么意思？
非侵入式的框架，利用反射和动态代理，不会强迫你实现Spring的接口或继承Spring的类，
去除spring使用其他的框架不需要修改代码，可以继续运行。
！！！设计原则是 “高内聚，低耦合”，”零侵入性“
！IOC inverse of control控制反转/DI dependency injection IOC是设计模式，bean控制权交给spring容器，DI是一种实现技术
传统方法在代码里”直接实例化（new）依赖的对象“，需要在！编译时绑定对象，造成高度耦合，难以测试。
依赖注入，在代码里“声明依赖的接口，无需主动请求“，在！运行时由Spring组装器装配好并注入。

！AOP（用到反射、动态代理）：运行时检查和加载类、构建对象，目标对象实现接口、Invokationhandler、Proxy，
对目标对象方法拦截、增强，日志、事务等切面分离


/org/springframework/beans/factory/BeanFactory接口，bean工厂提供最基本getBean()重载方法（根据名称、类型）
<T> getBean(Class<T> requiredTypr):获取Spring容器中属于requiredType类型的唯一的Bean实例。
Object getBean(String name)：返回Sprin容器中id为name的Bean实例。
<T> T getBean(String name,Class requiredType)：返回容器中id为name,并且类型为requiredType的Bean
以及containBean(String name):判断Spring容器是否包含id为name的Bean实例等方法。


org.springframework.context.ApplicationContext接口继承BeanFactory等，表示应用上下文，一个应用上下文管理着一组bean。
容器以至少一个应用上下文存在。
ApplicationContext有多种实现：
可基于java配置类加载、类路径下（所有类路径，包含jar文件）的xml加载、文件路径下的xml加载等
AnnotationConfigApplicationContext、FileSystemXmlApplicationContext、ClassPathXmlApplicationContext
WebApplicationContext继承了ApplicationContext接口，它增加了WEB应用特性，还可以视图解析、主题解析、映射，
通过ServletContext与servlet关联 ，WebApplicationContext被绑定在ServletContext上(通过ContextLoaderListener绑定)，
可以通过RequestContextUtils获取WebApplicationContext。

根据层次关系，bean可以访问同一个或者父类应用上下文，不能访问兄弟应用上下文的bean

提到的Aware相关接口指的是什么？平常会自己会用Aware相关接口吗？
Spring的依赖注入的最大亮点是所有的Bean对Spring容器的存在是没有意识的，所以耦合度低，
如果不是特别需要，一般不建议通过实现接口让Bean拥有访问容器的能力，因为需要实现Aware接口导致代码与Spring耦合在一起。
！Aware接口是为了让bean获取到创建它的应用上下文以及它在应用上下文中的属性，调用Spring所提供的资源。
BeanNameAware接口是为了让Bean能够感知到自身在Spring容器中的id属性。
org.springframework.beans.factory.BeanFactoryAware
实现了BeanFactoryAware接口的类，能够获取到BeanFactory对象。
org.springframework.context.ApplicationContextAware等继承Aware接口
”！实现BeanFactoryAware！接口的Bean实例将会拥有对容器的访问能力“。BeanFactoryAware接口仅有如下一个方法：
SetBeanFactory(BeanFactory beanFactory)：该方法将由Spring调用，将创建它的Spring容器作为参数传入该方法。

！！！为什么使用ApplicationContextAware接口：
一。可以获取到bean在容器内的id
二。”一个项目中有些类不受spring容器管理却需要使用受spring管理的bean“，这时候不能通过正常的方式注入bean，
我们可以编写一个工具类（也被Spring管理）来实现ApplicationContextAware，
通过工具类来获取我们需要的bean然后供不在spring容器中的类调用。



DI dependency injection 依赖注入
创建隐式、显式依赖关系：
如注解声明为@component，.xml配置文件以及基于Java的配置（@Configuration @Bean）。
通过ApplicationContext应用上下文读取依赖关系进行“装配”，并自动注入bean。

装配方式显式（xml、JavaConfig）、隐式（bean发现自动装配），推荐隐式>javaConfig>xml
？？？什么时候必须使用显示配置（想装配第三方库的组件，无法直接在三方代码上加@Component！！！）
显示装配推荐javaconfig，更强大、类型安全、对重构友好，但配置代码不能侵入逻辑代码，所以单独放一个包
@Configuration声明为配置类，再给方法添加@Bean声明bean实例，
！！！根据return可返回随机类型，默认id和方法名一样；默认单例模式，对同一个方法的调用会被spring拦截，每次返回同一个Bean
如果有引用的对象可以直接叠加方法，或者传入该类型

隐式两步：1组件扫描（component scan）自动发现应用上下文中的bean，可用注解或者xml的ComponentScan开启，
@ComponentScan默认扫描这个包以及子包（也可以指定多个包，basePackages），扫描的类标注@Component
2自动装配（autowiring）自动满足依赖关系



注入方式：（！！！属性注入、构造器注入、setter()等方法注入）
-------显式装配（xml或者@Configuration、@Bean）的注入方式：
1反射模式
<bean id="car1" class="com.home.factoryMethod.Car">
</bean>
通过class属性全类名， Spring利用java反射机制创建bean（Class.forName()）。

2静态、实例工厂方法模式(本文重点)
在工厂方法模式中， Spring利用反射机制先找到Factory类，然后利用Factory再去生成bean对象。
而Factory Mothod方式也分两种， 分别是静态工厂方法 和 实例工厂方法。
静态工厂方式就是指Factory类不本身不需要实例化， 这个Factory类中提供了1个静态方法来生成bean对象

-------隐式装配（@component）的注入方式：
1属性（字段）注入
@Autowired注解直接放在Field字段上完成注入
2构造器注入
@Autowired注解放在构造器上，通过构造器参数类型自动装配
3setter()方法以及任意名称和多个参数的方法注入
@Autowired注解放在方法上，通过方法参数类型自动装配

！！！注入方式优缺点：
1.基于constructor的注入，！会固定依赖注入的顺序，bean对象之间的循环依赖抛出异常BeanCreationException！
强制性的、不可变的依赖使用（初始化时强制 对象可final修饰）

2.基于setter的注入，只有当对象被需要时注入，而不是初始化时注入，
Spring容器”提前暴露刚完成构造器注入的bean“（但未完成其他步骤（如setter注入））来解决循环依赖。
可选或多变的依赖使用（对象不能被fianl修饰）

3.基于字段注入，简短可读性高（对象不能被fianl修饰）；
”类跟DI容器强耦合“。
例如单元测试时，如果不依赖DI容器，又没有构造注入，set方法注入，没办法直接初始化这个类
依赖的字段出现null。


启动类@SpringBootApplication包括
@SpringBootConfiguration 点开发现还是应用了@Configuration,相当于把该启动类作为spring的xml配置文件中的<beans>
@EnableAutoConfiguration 实现自动装配的注解，借助@Import的支持收集和注册相关的bean定义，将所有符合条件的@Configuration配置都加载
@ComponentScan 需要装配的类扫描，默认扫描这个包以及子包，扫描的类标注@Component

如果@Component没传Id，默认为类名第一个字母小写。也可以使用Java依赖注入的规范@Named替换
最后使用@Autowired注入也可以通过应用上下文getBean()
注入可以用于成员变量、构造器、setter方法以及其他任意方法，
成员变量包括实例变量和类变量，成员方法包括实例方法和类方法。
@Resource默认按 byName自动注入
1. 如果同时指定了name和type，则从Spring上下文中找到唯一匹配的bean进行装配，找不到则抛出异常
2. 如果指定了name，则从上下文中查找名称（id）匹配的bean进行装配，找不到则抛出异常
3. 如果指定了type，则从上下文中找到类型匹配的唯一bean进行装配，找不到或者找到多个，都会抛出异常
4. 如果既没有指定name，又没有指定type，则自动按照byName方式进行装配；如果没有匹配，则回退为一个原始类型进行匹配，如果匹配则自动装配；
@Autowired默认按类型装配（这个注解是属业spring的），默认情况下必须要求依赖对象必须存在，如果要允许null值，
可以设置它的required属性为false，如：@Autowired(required=false) 
当一个接口多个实现时，按照类型装配会出现歧义，可以结合@Qualifier使用名称装配
如果是默认的名称，当重构类名后，@Qualifier("name")就不一样了，所以可以自己设置一个全局唯一名字


其他注解
@Controller 
@RequestMapping 和 @GetMapping @PostMapping 
处理requet uri 部分（这里指uri template中variable，不含queryString部分）的注解：   @PathVariable;
处理request header部分的注解：   @RequestHeader, @CookieValue;
处理request body部分的注解：@RequestParam,  @RequestBody;
！！！在使用@RequestMapping后，返回值通常解析为跳转路径，加上@responsebody后返回结果不会被解析为跳转路径，
而是直接写入HTTP response body中。比如异步获取json数据，加上@responsebody后，会直接返回json数据。
如果返回模型对象而非简单字符串，又没@responsebody注解，将会根据请求路径推断逻辑视图（jsp等）
（！！！@responsebody 告诉spring，将返回的对象作为资源发送给客户端，并转换为客户端接受的形式，
DispatcherServlet会考虑请求头部Accept信息）
3！！！@ResponseEntity合理发送错误信息到客户端，
比如查询为空返回null，但显示200OK不合理。利用@ResponseEntity指定响应状态码如404，并且把原对象（null）替换为定义的错误信息对象

@ResponseEntity 相比@ResponseBody，可以设置状态码
@ResponseEntity和@ResponseBody都会绕过视图解析器

@Service @Repository 

@Scope("prototype")
定义Bean的作用域和生命周期


@PostConstruct 
相当于init-method,使用在方法上，当Bean初始化后执行。

@PreDestroy 
相当于destory-method，使用在方法上，当Bean销毁前执行。

@Transactional  
声明式事务
添加注解的方法执行会被封装在事务中，如果方法抛出异常，事务将回滚

@PropertySource用于导入.properties的属性配置文件
再注入Enviroment 或者 使用@value 通常用于配置类读取配置文件
避免硬编码（避免字符串配置写进代码）
！！！区别
@ImportResource用于导入.xml的Bean信息的配置文件
@ImportResource指示包含要导入的bean定义的一个或多个资源。它的功能比较像@Import注解，就是向容器内导入Bean。
只是@ImportResource它导入的是一个xml配置文件，然后通过解析xml文件的方式再把解析好的Bean信息导入到Spring容器内。


（springmvc中有两种很普遍的AOP实现：
1.过滤器（Filter）
2.拦截器（Interceptor））
aop的实现主要有两种方式，一种是通过回调函数，另一种是代理。
AOP aspect-oriented programming 面向切面编程（反射、动态代理实现，基于切点的接口。如果没有接口使用cglib）
把核心业务逻辑组件和横切面（比如日志、事务、安全spring security管理等）分离（解耦）开，并且可以实现拦截。切面即服务模块，切点即核心业务
使这些服务模块化，以声明（如xml<bean> <aop> 利用AspectJ切点表达式语言，前后置通知）的方式去包裹核心业务。

实现方式比较：
（使用AspectJ编译器）
在编译时、类加载时完成，
可以编织字段、方法、构造函数等......
可以在所有域对象上实现
在执行应用程序之前前, 各方面直接在代码中进行织入
AspectJ 在应用程序执行之前将这些方面编织到主代码中, 因此没有额外的运行时开销, 性能更好。

（spring AOP 采用JDK动态代理 或者 无接口CGLIB 代理）
是基于代理的框架，直到运行时才创建代理对象，对性能产生负面影响
仅支持方法级编织（代理是由目标对象创建的, 并且切面应用在这些代理上）
只能在由 Spring 容器管理的 bean 上实现
Spring AOP 显然更简单, 因为它不会在我们的构建过程中引入任何额外的编译器。


切面：横切关注点（（安全、事务、日志））被模块化为特殊的类，这些类称为切面
通知（何时、完成什么）：切面也需要完成工作。在 AOP 术语中，切面的工作被称为通知。除了描述切面要完成的工作，通知还解决何时执行这个工作。
Spring 切面可应用的 5 种通知类型：
Before——在方法调用之前调用通知
After——在方法返回或者抛出异常后调用，无论方法执行成功与否
After-returning——在方法返回之后调用通知
After-throwing——在方法抛出异常后进行通知
Around——通知包裹了被通知的方法，在被通知的方法调用之前和调用之后执行自定义的行为
try {
 4        //@Before
 5        result = method.invoke(target, args);
 6        //@After
          //@AfterReturning
 7        return result;
 8    } catch (InvocationTargetException e) {
 9        Throwable targetException = e.getTargetException();
11        throw targetException;
		  //@After
		  //@AfterThrowing
12    } finally {
14    }

连接点：连接点是一个应用执行过程中能够插入一个切面的点。连接点是一个虚拟的概念，可以理解为所有满足切点扫描条件的所有的时机

切点（何处）：pointcut标签表示一个切点，也就是满足条件被扫描到的目标方法。
相对于通知的何时、完成什么，切点定义了何处，有助于缩小切面通知的连接点范围。
如下示例表示匹配返回值为任意类型，并且是com.spring.service包及其子包下的任意类的名称为businessService的方法，
而且该方法不能有任何参数：
execution(* com.spring.service..*.businessService())

引入：添加方法或字段到被通知的类，Spring允许引入新的接口到任何被通知的对象。
这不就是把切面（也就是新方法属性：通知定义的）用到目标类中吗

织入：组装切面来创建一个被通知对象。把切面应用到目标对象来创建新的代理对象的过程。

--------------------------------------------------------------
profile特性以及条件化配置
传统是CI（DEV）、STG（QA）、PRD环境分别有配置文件，单独构建应用。
而spring是运行时决策。将不同的bean定义整理到多个profile，@profile应用在类或方法级别，运行前确保对应的profile激活（active）
spring Boot除了支持所有的profile配置，通过配置文件中spring.profile.active激活 或者 在程序中设定：
SpringApplication.setAdditionalProfiles() 或者 pom.xml文件中的spring-boot-maven-plugin中配置
但是Spring Boot带来的最重要的特性是profile-specific profiles文件，这些文件的命名方式需要遵循applications-{profile}.properties的格式。

通过模板封装去除样板式代码，例如Spring的JdbcTemplate避免传统JDBC建立连接、创建语句对象、查询数据、关闭连接、捕获异常的样板式代码

MVC模式:构建Web应用的方法，分离界面逻辑和业务逻辑。Model+View+Controller
View视图（如css、html、js）---通过js联系和返回---Controller控制器---操作---Model模型（业务逻辑对象、也可以是存取数据的对象或 JAVA POJO）。
Controller之间是不可以相互调用、各Model之间是可以相互调用的
MVC框架：Apache struts、springMVC 等
springmvc工作流程
1、 用户向服务端发送一次请求，这个请求会先到前端控制器DispatcherServlet(也叫中央控制器)。
2、DispatcherServlet接收到请求后会调用HandlerMapping处理器映射器。由此得知，该请求该由哪个Controller来处理（并未调用Controller，只是得知）
3、DispatcherServlet调用HandlerAdapter处理器适配器，告诉处理器适配器应该要去执行哪个Controller
4、HandlerAdapter处理器适配器去执行Controller并得到ModelAndView(数据和视图)，并层层返回给DispatcherServlet
5、DispatcherServlet将ModelAndView交给ViewReslover视图解析器解析，然后返回真正的视图。
6、DispatcherServlet将模型数据填充到视图中
7、DispatcherServlet将结果响应给用户
组件说明
DispatcherServlet：前端控制器，也称为中央控制器，它是整个请求响应的控制中心，组件的调用由它统一调度。
HandlerMapping：处理器映射器，它根据用户访问的 URL 映射到对应的后端处理器 Handler。也就是说它知道处理用户请求的后端处理器，但是它并不执行后端处理器，而是将处理器告诉给中央处理器。
HandlerAdapter：处理器适配器，它调用后端处理器中的方法，返回逻辑视图 ModelAndView 对象。
ViewResolver：视图解析器，将 ModelAndView 逻辑视图解析为具体的视图（如 JSP）。
Handler：后端处理器，对用户具体请求进行处理，也就是我们编写的 Controller 类。

springboot默认配置DispatcherServlet 是映射到“/”的，可以在application.properties修改配置：server.servlet-path

-------------------------------------------------------------------------------------------
https://www.cnblogs.com/hhhshct/p/8808115.html
！！！springmvc：三大器在springboot中使用时，首先实现相应的接口定义类，然后通过配置类将其加入到spring容器中，从而实现相应的功能。
1.监听器 一个监听器实例只能在容器初始化时调用一次
主要作用是： 做一些初始化的内容添加工作、设置一些基本的内容、比如一些参数或者是一些固定的对象等等。
如SpringMVC的监听器org.springframework.web.context.ContextLoaderListener，
实现了SpringMVC容器的加载、Bean对象创建、DispatchServlet初始化等。
------------------------------------------------------------------------
2.过滤器（Filter）过滤器就是过滤的作用，一个过滤器实例只能在容器初始化时调用一次
过滤器是在请求进入tomcat容器后，但请求进入servlet之前进行预处理的。请求结束返回也是，是在servlet处理完后，返回给前端之前。
过滤器只能在请求的前后使用
属于面向切面编程（AOP）的一种运用
在web开发中过滤一些我们指定的url
、获取我们想要获取的数据（在过滤器中修改字符编码；在过滤器中修改HttpServletRequest的一些参数，包括：过滤低俗文字、危险字符等。）
实现Filter接口
@Component
@WebFilter(urlPatterns = "/Blogs",filterName = "blosTest")
public class TestFilter implements Filter{}
我们一步步来
1.@Component就是把这个类注入到IOC容器中
2.@WebFilter(urlPatterns = "/Blogs",filterName = "blosTest")说明这是一个web过滤器，它拦截的url为
/Blogs
，过滤器名字为
blogsTest
------------------------------------------------------------------------
3.拦截器（Interceptor）一个拦截器实例在一个controller生命周期之内可以多次调用
拦截器可以调用IOC容器中的各种依赖，而过滤器不能
属于面向切面编程（AOP）的一种运用
只能对controller请求进行拦截。
拦截器是基于web框架的调用，因此可以使用Spring的依赖注入（DI）进行一些业务操作，
public class MyInterceptor implements HandlerInterceptor {
    //在请求处理之前进行调用（Controller方法调用之前
    @Override
    public boolean preHandle(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o) throws Exception {
        System.out.printf("preHandle被调用");
        return true;    //如果false，停止流程，api被拦截
    }
 
    //请求处理之后进行调用，但是在视图被渲染之前（Controller方法调用之后）
    @Override
    public void postHandle(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, ModelAndView modelAndView) throws Exception {
        System.out.println("postHandle被调用");
    }
 
    //在整个请求结束之后被调用，也就是在DispatcherServlet 渲染了对应的视图之后执行（主要是用于进行资源清理工作）
    @Override
    public void afterCompletion(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, Exception e) throws Exception {
        System.out.println("afterCompletion被调用");
    }
}
它依次实现了三个方法
相比过滤器，拦截器还需要在springmvc中注入
所以我们打开启动类，写入以下代码

public class WarApplication {
 
    public static void main(String[] args) {
        SpringApplication.run(WarApplication.class, args);
    }
 
    //mvc控制器
    //@Configuration
    static class WebMvcConfigurer extends WebMvcConfigurerAdapter{
        //增加拦截器
        public void addInterceptors(InterceptorRegistry registry){
            registry.addInterceptor(new MyInterceptor())    //指定拦截器类
                    .addPathPatterns("/Handles");        //指定该类拦截的url
        }
    }
}
------------------------------------------------------------------------------
SOAP Simple Object Access Protocol 简单对象访问协议，是交换数据的一种协议规范，是一种轻量的、简单的、基于XML（标准通用标记语言下的一个子集）的协议
1在SOAP模式把HTTP作为一种通信协议，而不是应用协议。所以http中的表头，错误信息等全部无视。实际上http有 put get post delete等方法。
因为SOAP并不假定传输数据的下层协议，因此必须设计为能在各种协议上运行。即使绝大多数SOAP是运行在HTTP上，使用URI标识服务，
SOAP也仅仅使用POST方法发送请求，用一个唯一的URI标识服务的入口。
2举一个图书馆在线查询管理系统为例，服务提供者必须为每一本书提供一个内部标识，然后可能定义一个listBooks操作来返回一系列图书，
一个getBook操作来返回指定的图书，一个createBook操作来向数据库加入新增的图书，一个deleteBook操作来删除作废的图书，
每个操作都有各自的参数，尤其是用内部标识来标识操作的图书。这种设计被诟病之处，在于deleteBook操作也要用POST方法来发送，
而其实HTTP协议有更和逻辑的DELETE方法. 
3耦合度高，SOAP下客户端和服务器，一端的改变需要另一端改变。
4只允许XML

REST Representational State Transfort 代表状态转移 REST只是一种架构风格，而不是协议或标准。
1它面向资源，甚至连服务也抽象成资源，它服务器无状态，它和HTTP紧密结合，把HTTP协议利用到了极限（也可以其他协议），构建的成本减少了。
2HTTP method中的 POST GET PUT DELETE 都是与请求方法对应的，提交的请求中，服务器可以通过请求方式直接判断请求动作是要进行什么操作
REST设计，为每一个资源（此处是图书）指定一个唯一的URI，而不用再在服务器端开发一套资源访问机制。
而用HTTP的4种方法GET、POST、PUT、DELETE直观地表示获取、创建、更新和删除
同时图书集合也是和单本的图书不同的资源，如果用/books来代表图书列表，/books/ID来代表标识为ID的图书，那么对/books的GET操作就代表返回整个图书列表，
对/books/ID的DELETE操作代表删除指定的图书，等等。
又如只需简单配置服务器就能规定资源的访问权限，例如通过禁止非GET访问把资源设成只读。
3低耦合，访问一个rest服务不需要知道它的Api细节（知道资源就对应所有操作），并且可以通用扩展
4根据request header 参数 "Accept" 返回同一资源的不同格式（restful+@ResponseBody 实现前后端分离）
as application/xml or application/json for POST 
and /user/1234.json or GET /user/1234.xml for GET.


结合restFul？
1以资源为中心，对资源的增删查改操作很好的和http的post、delete、get、put结合，
依靠options的发现机制，发现资源的可用操作，例如只用get方法限定资源只读。
2结合@ResponseBody绕过视图解析器，通过客户端请求的类型Accept字段，返回任意格式（如json）的
Content-Type数据给客户端，直接写入HTTP responsebody中。
如果返回模型对象而非简单字符串，又没@responsebody注解，将会根据请求路径推断跳转路径，把模型数据传给视图解析器，生成逻辑视图
3@ResponseEntity合理发送错误信息到客户端
结合@Responsestatus以及自定义异常，返回不同的状态码给客户端，
例如将@ResponseStatus注解加在目标方法上，同时将@ResponseStatus注解加在自定义异常类上
正常响应返回200 OK，资源不存在返回404。等等
-------------------------------------------------------------------------------
为什么要用spring？
零侵入性、高内聚低耦合的原则，通过AOP（基于反射）、IOC（DI）实现，
方便集成第三方框架。

！！！为什么要用springboot？
1。简化部署，集成tomcat
在使用 Spring 时，项目部署时需要我们在服务器上部署 tomcat，然后把项目打成 war 包扔到 tomcat里，
在使用 Spring Boot 后，我们不需要在服务器上去部署 tomcat，因为 Spring Boot 内嵌了 tomcat，我们只需要将项目打成 jar 包，
使用 java -jar xxx.jar一键式启动项目。
2。简化依赖，多个启动starter项目可供使用；
3。maven保持版本一致，根据starter-parent的version自动确定保持一致version；
4。简化配置，更多注解替代xml
启动类的三个注解：声明启动类为配置类，启用自动装配（借用import），指定扫描包（发现被声明管理的bean）
5。简化环境切换，激活生产开发测试环境
多个profile通过指定active激活

SpringBoot如何找到启动类、如何启动、是放到tomcat吗？如何关闭？遇到过什么问题吗？启动的时候加载的信息是什么东西？
启动类
1@SpringBootApplication注解包括：
@SpringBootConfiguration 点开发现还是应用了@Configuration,相当于把该启动类作为spring的xml配置文件中的<beans>
@EnableAutoConfiguration 实现自动装配的注解，借助@Import的支持收集和注册相关的bean定义，将所有符合条件的@Configuration配置都加载
@ComponentScan 需要装配的类扫描，默认扫描这个包以及子包，扫描的类标注@Component
2SpringApplication.run()静态方法

如何启动：Spring Boot 内嵌了 tomcat，将项目打成可执行的jar 包，使用 java -jar xxx.jar一键式启动项目。
如何关闭：
1通过HTTP发送shutdown信号（application.properties中配置endpoints.shutdown）
#启用shutdown
endpoints.shutdown.enabled=true
#禁用密码验证
endpoints.shutdown.sensitive=false
需要停止服务时，向服务器post该请求即可，如：
curl -X POST host:port/shutdown
可以非常方便的进行远程操作，但是需要注意的是，正式使用时，必须对该请求进行必要的安全设置


在linux正常启动，在windows下本地调试启动时读取不到配置文件，修改读取的路径全限定名。

启动时加载的信息：所有controller的方法和url映射信息，运行的host和端口等


注入组件的两种方式
1@ComponentScan +@Component
直接在代码上添加如上注解，导入自己写的类。
2@Configuration + @Bean（类似XML）
导入的第三方包里面的组件。因为我们无法直接在三方代码上加@Component。
使用Spring提供的 FactoryBean（工厂Bean）（类似XML静态实例工厂）
a. 默认获取到的是工厂bean调用getObject创建的对象
b. 要获取工厂Bean本身，我们需要给id前面加一个&colorFactoryBean

使用Import管理配置类
假设有N个配置类，我们可以通过在某一个配置类中用@Import其他所有配置类，
这样在AnnotationConfigApplicationContext注册时就只要注册一个配置类即可，不需要记住那么多配置类。
AnnotationConfigApplicationContext context =
                new AnnotationConfigApplicationContext(
                MainConfig.class,
                OtherConfig.class, 
                ImportConfig.class);
如可以在MainConfig.class上@Import其他的配置类




beanfactory和factorybean区别？？？
1BeanFactory是个Factory，是容器最基本的接口，提供了根据name或者类型获取bean的getBean等方法，
ApplicationContext接口继承BeanFactory等，表示应用上下文，又有读取XML和配置类信息的多种实现。

2FactoryBean是个Bean，是一个能生产或者修饰对象的工厂Bean,它的实现与设计模式中的工厂模式和修饰器模式类似。

一般情况下，Spring通过反射机制利用<bean>的class属性指定实现类实例化Bean，
在某些情况下，实例化Bean过程比较复杂，如果按照传统的方式，则需要在<bean>中提供大量的配置信息。
”配置方式的灵活性是受限的“，这时采用编码的方式可能会得到一个简单的方案。
Spring为此提供了一个org.springframework.bean.factory.FactoryBean的工厂类接口，用户可以通过实现该接口定制实例化Bean的逻辑。

如果一个Bean特别复杂，需要做很多处理，则可以用FactoryBean来完成。使用有两步：
实现FactoryBean重写getObject()方法；
使用@Bean注入实现的FactoryBean；
用getBean(String BeanName)获取，会在getObject()方法中返回。
要想获取FactoryBean的实现类，得在getBean(String BeanName)中的BeanName之前加上&,写成getBean(String &BeanName)



Spring IoC中Bean的生命周期？谁来管理Bean的生命周期？为什么这么长？
定义Bean的作用域和生命过程
@Scope()值有:
singleton,单例，整个应用一个，被容器缓存。
创建起容器时就同时自动创建了一个bean的对象，不管你是否使用，但我们可以指定Bean节点的 lazy-init=”true” 来延迟初始化
对无状态的 bean 则应该使用 singleton

prototype,原型，每次创建一个新的，不被容器缓存，创建后将不再跟踪其生命周期，交给客户端代码管理。
在我们创建容器的时候并没有实例化，而是当我们获取bean的时候才会去创建一个对象，而且我们每次获取到的对象都不是同一个对象。
对有状态的 bean 应该使用 prototype 

request,一个请求一个
每一次 HTTP 请求都会产生一个新的bean，同时该bean仅在当前HTTP request内有效。

session,一个会话一个（针对关联用户，比如一个用户一个购物车）
当HTTP session最终被废弃的时候，在该HTTP session作用域内的bean也会被废弃掉。

globalSession
request、session 和 global session 三种作用域仅在基于web的应用中使用（不必关心你所采用的是什么web应用框架），
只能用在基于 web 的 Spring ApplicationContext 环境。


https://javadoop.com/post/spring-ioc
https://github.com/Snailclimb/JavaGuide/blob/master/docs/system-design/framework/spring/SpringBean.md
IOC如何实现的 springbean的原生接口 容器应用上下文 加载机制，autowired注入机制（构造器，set方法，字段注入优缺点）
ApplicationContext容器中，Bean的生命周期流程大致如下：
1.根据spring的配置文件或者配置类，获得bean定义和隐式，显式的依赖关系，进行装配，获得一个beanName-> beanDefinition的”注册map“
2.会（利用”反射“）对”！scope为singleton且非懒加载的bean“进行实例化，注入所有的属性，
3.如果Bean实现了BeanNameAware接口，会回调该接口的setBeanName()方法，传入该Bean的id，此时该Bean就获得了自己在配置文件中的id，
4.如果Bean实现了BeanFactoryAware接口,会回调该接口的setBeanFactory()方法，传入该Bean的BeanFactory，这样该Bean就获得了自己所在的BeanFactory，
5.如果Bean实现了ApplicationContextAware接口,会回调该接口的setApplicationContext()方法，传入该Bean的ApplicationContext，这样该Bean就获得了自己所在的ApplicationContext，
6.如果有Bean实现了BeanPostProcessor接口，则会回调该接口的postProcessBeforeInitialzation()方法，
7.如果Bean实现了InitializingBean接口，则会回调该接口的afterPropertiesSet()方法，
8.如果Bean配置了init-method方法，则会执行init-method配置的方法（同@PostConstruct） ，
9.如果有Bean实现了BeanPostProcessor接口，则会回调该接口的postProcessAfterInitialization()方法，
10.经过流程9之后，就可以正式使用该Bean了,对于scope为singleton的Bean,Spring的ioc容器中会缓存一份该bean的实例，
而对于scope为prototype的Bean,每次被调用都会new一个新的对象，生命周期就交给调用方管理了，不再是Spring容器进行管理了
11.容器关闭后，如果Bean实现了DisposableBean接口，则会回调该接口的destroy()方法，
12.如果Bean配置了destroy-method方法（同@PreDestroy ），则会执行destroy-method配置的方法，至此，整个Bean的生命周期结束


InitializingBean接口：
1、Spring为bean提供了两种初始化bean的方式，实现InitializingBean接口，实现afterPropertiesSet方法，
或者在配置文件中通过init-method指定，两种方式可以同时使用。
2、实现InitializingBean接口是直接调用afterPropertiesSet方法，比通过反射调用init-method指定的方法效率要高一点，
但是init-method方式消除了对spring的依赖！！！。
3、如果调用afterPropertiesSet方法时出错，则不调用init-method指定的方法，接口初始化在前。

DisposableBean接口：提供了一个唯一的方法destory()。
同样在destroy-method方法前，实现接口也增加了bean和spring的耦合！！！

！！！BeanPostProcessor接口（BBP）：后置处理器，指的是“ 对象创建后处理器 ”，在BBP之后bean才是真正可用的
通过该接口中的方法在bean实例化、配置以及其他”初始化方法前后添加一些我们自己的逻辑“，BBP是连接IOC和AOP的桥梁。
postProcessBeforeInitialization	实例化、依赖注入完毕，
在调用显示的初始化之前完成一些定制的初始化任务
postProcessAfterInitialization	实例化、依赖注入、初始化完毕时执行

”！！！AOP最终放进Spring容器的，必须是代理对象，而不是原先的对象“ ，这样别的对象在注入时，才能获得带有切面逻辑的代理对象。
Spring正是利用了BBP，在postProcessBeforeInitialization或者postProcessAfterInitialization方法中，对对象进行判断，
看他需不需要织入切面逻辑，如果需要，那我就根据这个对象，生成一个代理对象，然后返回这个代理对象，
那么最终注入容器的，自然就是代理对象了。


ApplicationContext的初始化逻辑（考虑IOC与AOP）：
读取包含bean定义配置信息，获取依赖关系，进行注册获得一个 beanName-> beanDefinition 的 map
==》通过反射实例化bean，注入属性
==》如果实现了Aware接口，回调接口方法传入要获取的容器信息
==》BeanPostProcessor接口：后置处理器的before方法==》InitializingBean接口初始化，init-method方法（同@PostConstruct）初始化
==》BeanPostProcessor接口：后置处理器的after方法==》ioc容器中缓存singleton的Bean实例，而scope为prototype的Bean,
每次被调用都会new一个新的对象，生命周期就交给调用方不再是Spring容器进行管理
==》容器关闭，DisposableBean接口destory()，destroy-method方法（同@PreDestroy ）


如何自己实现一个IOC容器？？？
（读取信息封装Map<String,Bean>集合，实现BeanFactory的接口初始化容器，遍历集合通过”反射“创建对象，
调用自定义的初始化方法，对于单例缓存起来，对于原型每次new一个，再容器关闭时调用destory方法）
程序中所有的Bean之间的依赖关系我们是放在一个xml文件中（或者配置类）进行维护的,就是applicationContext.xml　　
ConfigManager类的功能是读取xml,并将所有读取到bean信息封装到我们创建的一个Map<String,Bean>集合中,用来在初始化容器时创建bean对象.
定义一个BeanFactory的接口,接口中有一个getBean(String name)方法,用来返回你想要创建的那个对象.
然后定义一个该接口的实现类ClassPathXmlApplicationContext.就是在这个类的构造方法中,初始化容器,
通过调用ConfigManager的方法返回的Map集合,通过反射一一创建bean对象.
这里需要注意,对象的创建有两个时间点,这取决与bean标签中scope属性的值:
如果scope="singleton",那么对象在容器初始化时就已创建好,用的时候只需要去容器中取即可.
如果scope="prototype",那么容器中不保存这个bean的实例对象,每次开发者需要使用这个对象时再进行创建.





spring事务
@Transactional声明式事务，需要在”入口类“添加 @EnableTransactionManagement 注解，来开启事务。
spring声明式事务，spring使用AOP来支持声明式事务，会根据事务属性，自动在方法调用之前决定是否开启一个事务，
并在方法执行之后决定事务提交或回滚(异常)事务。
Spring并不直接管理事务，而是提供了多种事务管理器，具体的事务管理机制对Spring来说是透明的
他们将事务管理的职责委托给hibernate或者JTA等持久化机制所提供的相关平台框架的事务来实现。


Spring事务中的隔离级别（多了一个默认级别，其实就是后端数据库默认的隔离级别）
TransactionDefinition 接口中定义了五个表示隔离级别的常量：
TransactionDefinition.ISOLATION_DEFAULT: 使用后端数据库默认的隔离级别，Mysql 默认采用的
REPEATABLE_READ隔离级别 Oracle 默认采用的 READ_COMMITTED隔离级别. 
TransactionDefinition.ISOLATION_READ_UNCOMMITTED: 最低的隔离级别，允许读取尚未提交的数据变
更，可能会导致脏读、幻读或不可重复读
TransactionDefinition.ISOLATION_READ_COMMITTED: 允许读取并发事务已经提交的数据，可以阻止脏
读，但是幻读或不可重复读仍有可能发生
TransactionDefinition.ISOLATION_REPEATABLE_READ: 对同一字段的多次读取结果都是一致的，除非数据
是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生。
TransactionDefinition.ISOLATION_SERIALIZABLE: 最高的隔离级别，完全服从ACID的隔离级别。所有的事
务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻
读。但是这将严重影响程序的性能。通常情况下也不会用到该级别。


https://blog.csdn.net/hcmony/article/details/77850183
！！！Spring事务中的传播机制:当事务方法被另一个事务方法调用时，必须指定事务应该如何传播。
例如：方法可能继续在现有事务中运行，也可能开启一个新事务，并在自己的事务中运行。
！支持当前事务的情况：
TransactionDefinition.PROPAGATION_REQUIRED： 如果当前存在事务，则加入该事务；如果当前没有事
务，则创建一个新的事务。
TransactionDefinition.PROPAGATION_SUPPORTS： 如果当前存在事务，则加入该事务；如果当前没有事
务，则以非事务的方式继续运行。
TransactionDefinition.PROPAGATION_MANDATORY： 如果当前存在事务，则加入该事务；如果当前没有
事务，则抛出异常。（mandatory：强制性）
！不支持当前事务的情况：
TransactionDefinition.PROPAGATION_REQUIRES_NEW： 创建一个新的事务，如果当前存在事务，则把当
前事务挂起。
TransactionDefinition.PROPAGATION_NOT_SUPPORTED： 以非事务方式运行，如果当前存在事务，则把
当前事务挂起。
TransactionDefinition.PROPAGATION_NEVER： 以非事务方式运行，如果当前存在事务，则抛出异常。


事务的一些基本配置
public interface TransactionDefinition {
    int getPropagationBehavior(); // 返回事务的传播行为
    int getIsolationLevel(); // 返回事务的隔离级别，事务管理器根据它来控制另外一个事务可以看到本事务内的哪些数据
    int getTimeout();  // 返回事务必须在多少秒内完成
    boolean isReadOnly(); // 事务是否只读，事务管理器能够根据这个返回值进行优化，确保事务是只读的
}


！！！一个controller分别调用两个service再调用两个Dao@Trasactional注解加在哪里？
加在controller层。
一般我们的service层调用多个dao层，只需要在service层加一个事务注解@Transactional，在一个事务处理多个请求（对数据库的多次增删查改）。
如果我们的事务注解@Transactional加在dao层，那么只要与数据库做增删改，就要提交一次事务，永久修改数据库，后面再调用另外一个DAO。
考虑service中间throws Exception，对于整个的Service来说，应该是要完全回滚的，加在DAO层就只能回滚到当前的DAO，
所以这就破坏了事务的原子性。

@Transactional既可以作用于接口，接口方法上以及类，类的方法上。但是Spring官方不建议接口或者接口方法上使用该注解，
因为这只有在使用基于接口的代理时它才会生效。
Spring默认使用的是jdk自带的基于接口的代理



struts和springMVC区别
一、拦截机制的不同
Struts2是”！类级别“的拦截，每次请求就会创建一个Action，一个Action对应一个request，response上下文，属性参数是让多个方法共享的。
和Spring整合时Struts2的ActionBean注入作用域是！原型模式prototype，
Struts2中Action的一个方法可以对应一个url，而其类属性却被所有方法共享，这也就无法用注解或其他方式标识其所属方法了，只能设计为多例。

SpringMVC是”！方法级别“的拦截，一个方法对应一个Request，response上下文，参数的传递是直接注入到方法中的。
而每个方法同时又何一个url对应，方法间是独立的。
在Spring整合时，SpringMVC的Controller Bean默认！单例模式Singleton，所以默认对所有的请求，只会创建一个Controller，
如果要改变默认的作用域，需要添加@Scope注解修改。

Struts2有自己的拦截Interceptor机制，SpringMVC这是用的是独立的Aop方式。

二、底层框架的不同
Struts2采用Filter（StrutsPrepareAndExecuteFilter）实现，SpringMVC（DispatcherServlet）则采用Servlet实现。
Filter在容器启动之后即初始化，Servlet在是在调用时初始化。

三、性能、配置方面
Struts2是类级别的拦截，每次请求对应实例一个新的Action，需要加载所有的属性值注入，
SpringMVC实现了零配置，由于SpringMVC基于方法的拦截，有加载一次单例模式bean注入。所以，SpringMVC开发效率和性能高于Struts2。

spring MVC和Spring是无缝的。


附注：拦截器与过滤器的区别 ：
拦截器是基于java的反射机制的，而过滤器是基于函数回调。
拦截器不依赖与servlet容器，过滤器依赖与servlet容器。
拦截器只能对action请求起作用，而过滤器则可以对几乎所有的请求起作用。
在action的生命周期中，拦截器可以多次被调用，而过滤器只能在容器初始化时被调用一次


Servlet规范了解吗？Servlet的整个业务流程？
servlet生命周期
1.被创建，”首次调用时“执行且只执行一次init方法
2.提供服务，执行service方法，执行多次 
3.被销毁，当Servlet服务器正常关闭时，执行destroy方法，只执行一次。


为什么要用Mybatis，优点？
一种持久层框架，也属于ORM映射，把数据库的字段映射到实体类上。
mybatis为半自动化，更加灵活。
需要自己书写sql语句,sql语句可与代码分离，存放于xml配置文件中便于维护,也可以使用注解。
需要自己定义映射（ResultMapping）,配置列名=字段名也可完成自动映射。

mybatis实现查询/插入自增
原本是这样的：
　　将insert语句传入，正常执行insert操作，返回int永远是 0[失败] 或者 1[成功]
需求是这样的：
　　mybatis中insert操作，返回自增id，因为这个自增id需要给后续业务用到。
useGeneratedKeys设置使用自增主键，useGeneratedKeys="true"，并且传入指定的对象，
keyProperty="id" 指定哪个字段用接收insert之后返回的自增idkeyColumn="id"


mybatis自动生成https://www.cnblogs.com/tengyunhao/p/8575463.html
mybatis-generator-maven-plugin插件
<!--数据库链接URL，用户名、密码 -->
<!-- 生成模型的包名和位置-->
<!-- 生成映射文件的包名和位置-->
<!-- 生成DAO的包名和位置-->
<!-- 要生成的表 tableName是数据库中的表名或视图名 domainObjectName是实体类名-->

MyBatis介绍一下？你说到这是一个持久层框架，那你了解JPA规范吗？
mybatis核心组件











